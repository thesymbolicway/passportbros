'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require('@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css');

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _mapboxGlGeocoder = require('@mapbox/mapbox-gl-geocoder');

var _mapboxGlGeocoder2 = _interopRequireDefault(_mapboxGlGeocoder);

var _reactMapGl = require('react-map-gl');

var _viewportMercatorProject = require('viewport-mercator-project');

var _viewportMercatorProject2 = _interopRequireDefault(_viewportMercatorProject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VALID_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];

function fitBounds(bounds, viewport) {
  return new _viewportMercatorProject2.default(viewport).fitBounds(bounds);
}

function getAccessToken() {
  var accessToken = null;

  if (typeof window !== 'undefined' && window.location) {
    var match = window.location.search.match(/access_token=([^&/]*)/);
    accessToken = match && match[1];
  }

  if (!accessToken && typeof process !== 'undefined') {
    // Note: This depends on bundler plugins (e.g. webpack) inmporting environment correctly
    accessToken = accessToken || process.env.MapboxAccessToken; // eslint-disable-line
  }

  return accessToken || null;
}

var Geocoder = function (_Component) {
  _inherits(Geocoder, _Component);

  function Geocoder() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Geocoder);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Geocoder.__proto__ || Object.getPrototypeOf(Geocoder)).call.apply(_ref, [this].concat(args))), _this), _this.geocoder = null, _this.cachedInputValue = '', _this.initializeGeocoder = function () {
      var mapboxMap = _this.getMapboxMap();
      var containerNode = _this.getContainerNode();
      var _this$props = _this.props,
          mapboxApiAccessToken = _this$props.mapboxApiAccessToken,
          inputValue = _this$props.inputValue,
          zoom = _this$props.zoom,
          placeholder = _this$props.placeholder,
          proximity = _this$props.proximity,
          trackProximity = _this$props.trackProximity,
          bbox = _this$props.bbox,
          types = _this$props.types,
          country = _this$props.country,
          minLength = _this$props.minLength,
          limit = _this$props.limit,
          language = _this$props.language,
          filter = _this$props.filter,
          localGeocoder = _this$props.localGeocoder,
          options = _this$props.options,
          onInit = _this$props.onInit,
          position = _this$props.position;


      _this.geocoder = new _mapboxGlGeocoder2.default(_extends({
        accessToken: mapboxApiAccessToken,
        zoom: zoom,
        flyTo: false,
        placeholder: placeholder,
        proximity: proximity,
        trackProximity: trackProximity,
        bbox: bbox,
        types: types,
        country: country,
        minLength: minLength,
        limit: limit,
        language: language,
        filter: filter,
        localGeocoder: localGeocoder
      }, options));
      _this.subscribeEvents();

      if (containerNode) {
        containerNode.appendChild(_this.geocoder.onAdd(mapboxMap));
      } else {
        mapboxMap.addControl(_this.geocoder, VALID_POSITIONS.find(function (_position) {
          return position === _position;
        }));
      }

      if (inputValue !== undefined && inputValue !== null) {
        _this.cachedInputValue = inputValue;
      }

      _this.geocoder.setInput(_this.cachedInputValue);
      onInit(_this.geocoder);
    }, _this.getMapboxMap = function () {
      var mapRef = _this.props.mapRef;


      return mapRef && mapRef.current && mapRef.current.getMap() || null;
    }, _this.getContainerNode = function () {
      var containerRef = _this.props.containerRef;


      return containerRef && containerRef.current || null;
    }, _this.subscribeEvents = function () {
      _this.geocoder.on('clear', _this.handleClear);
      _this.geocoder.on('loading', _this.handleLoading);
      _this.geocoder.on('results', _this.handleResults);
      _this.geocoder.on('result', _this.handleResult);
      _this.geocoder.on('error', _this.handleError);
    }, _this.unsubscribeEvents = function () {
      _this.geocoder.off('clear', _this.handleClear);
      _this.geocoder.off('loading', _this.handleLoading);
      _this.geocoder.off('results', _this.handleResults);
      _this.geocoder.off('result', _this.handleResult);
      _this.geocoder.off('error', _this.handleError);
    }, _this.removeGeocoder = function () {
      var mapboxMap = _this.getMapboxMap();

      _this.unsubscribeEvents();

      if (mapboxMap && mapboxMap.removeControl) {
        _this.getMapboxMap().removeControl(_this.geocoder);
      }

      _this.geocoder = null;
    }, _this.handleClear = function () {
      _this.cachedInputValue = '';
      _this.props.onClear();
    }, _this.handleLoading = function (event) {
      _this.props.onLoading(event);
    }, _this.handleResults = function (event) {
      _this.props.onResults(event);
    }, _this.handleResult = function (event) {
      var result = event.result;
      var _this$props2 = _this.props,
          mapRef = _this$props2.mapRef,
          onViewportChange = _this$props2.onViewportChange,
          onResult = _this$props2.onResult;
      var id = result.id,
          bbox = result.bbox,
          center = result.center;

      var _center = _slicedToArray(center, 2),
          longitude = _center[0],
          latitude = _center[1];

      var bboxExceptions = {
        'country.3148': {
          name: 'France',
          bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
        },
        'country.3145': {
          name: 'United States',
          bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
        },
        'country.330': {
          name: 'Russia',
          bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
        },
        'country.3179': {
          name: 'Canada',
          bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
        }
      };
      var width = mapRef.current.props.width;
      var height = mapRef.current.props.height;
      var zoom = _this.geocoder.options.zoom;

      if (!bboxExceptions[id] && bbox) {
        zoom = fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { width: width, height: height }).zoom;
      } else if (bboxExceptions[id]) {
        zoom = fitBounds(bboxExceptions[id].bbox, { width: width, height: height }).zoom;
      }

      onViewportChange({
        longitude: longitude,
        latitude: latitude,
        zoom: zoom,
        transitionInterpolator: new _reactMapGl.FlyToInterpolator(),
        transitionDuration: 3000
      });
      onResult(event);

      if (result && result.place_name) {
        _this.cachedInputValue = result.place_name;
      }
    }, _this.handleError = function (event) {
      _this.props.onError(event);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Geocoder, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.initializeGeocoder();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.removeGeocoder();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.removeGeocoder();
      this.initializeGeocoder();
    }
  }, {
    key: 'getGeocoder',
    value: function getGeocoder() {
      return this.geocoder;
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return Geocoder;
}(_react.Component);

Geocoder.propTypes = {
  mapRef: _propTypes2.default.object.isRequired,
  containerRef: _propTypes2.default.object,
  onViewportChange: _propTypes2.default.func,
  mapboxApiAccessToken: _propTypes2.default.string,
  inputValue: _propTypes2.default.string,
  zoom: _propTypes2.default.number,
  placeholder: _propTypes2.default.string,
  proximity: _propTypes2.default.object,
  trackProximity: _propTypes2.default.bool,
  bbox: _propTypes2.default.array,
  types: _propTypes2.default.string,
  country: _propTypes2.default.string,
  minLength: _propTypes2.default.number,
  limit: _propTypes2.default.number,
  language: _propTypes2.default.string,
  filter: _propTypes2.default.func,
  localGeocoder: _propTypes2.default.func,
  position: _propTypes2.default.oneOf(VALID_POSITIONS),
  onInit: _propTypes2.default.func,
  onClear: _propTypes2.default.func,
  onLoading: _propTypes2.default.func,
  onResults: _propTypes2.default.func,
  onResult: _propTypes2.default.func,
  onError: _propTypes2.default.func,
  options: _propTypes2.default.object // deprecated and will be removed in v2
};
Geocoder.defaultProps = {
  onViewportChange: function onViewportChange() {},
  mapboxApiAccessToken: getAccessToken(),
  zoom: 16,
  placeholder: 'Search',
  trackProximity: false,
  minLength: 2,
  limit: 5,
  position: 'top-right',
  onInit: function onInit() {},
  onClear: function onClear() {},
  onLoading: function onLoading() {},
  onResults: function onResults() {},
  onResult: function onResult() {},
  onError: function onError() {}
};
exports.default = Geocoder;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJWQUxJRF9QT1NJVElPTlMiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJ2aWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJnZXRBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwid2luZG93IiwibG9jYXRpb24iLCJtYXRjaCIsInNlYXJjaCIsInByb2Nlc3MiLCJlbnYiLCJNYXBib3hBY2Nlc3NUb2tlbiIsIkdlb2NvZGVyIiwiZ2VvY29kZXIiLCJjYWNoZWRJbnB1dFZhbHVlIiwiaW5pdGlhbGl6ZUdlb2NvZGVyIiwibWFwYm94TWFwIiwiZ2V0TWFwYm94TWFwIiwiY29udGFpbmVyTm9kZSIsImdldENvbnRhaW5lck5vZGUiLCJwcm9wcyIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwiaW5wdXRWYWx1ZSIsInpvb20iLCJwbGFjZWhvbGRlciIsInByb3hpbWl0eSIsInRyYWNrUHJveGltaXR5IiwiYmJveCIsInR5cGVzIiwiY291bnRyeSIsIm1pbkxlbmd0aCIsImxpbWl0IiwibGFuZ3VhZ2UiLCJmaWx0ZXIiLCJsb2NhbEdlb2NvZGVyIiwib3B0aW9ucyIsIm9uSW5pdCIsInBvc2l0aW9uIiwiTWFwYm94R2VvY29kZXIiLCJmbHlUbyIsInN1YnNjcmliZUV2ZW50cyIsImFwcGVuZENoaWxkIiwib25BZGQiLCJhZGRDb250cm9sIiwiZmluZCIsIl9wb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldElucHV0IiwibWFwUmVmIiwiY3VycmVudCIsImdldE1hcCIsImNvbnRhaW5lclJlZiIsIm9uIiwiaGFuZGxlQ2xlYXIiLCJoYW5kbGVMb2FkaW5nIiwiaGFuZGxlUmVzdWx0cyIsImhhbmRsZVJlc3VsdCIsImhhbmRsZUVycm9yIiwidW5zdWJzY3JpYmVFdmVudHMiLCJvZmYiLCJyZW1vdmVHZW9jb2RlciIsInJlbW92ZUNvbnRyb2wiLCJvbkNsZWFyIiwiZXZlbnQiLCJvbkxvYWRpbmciLCJvblJlc3VsdHMiLCJyZXN1bHQiLCJvblZpZXdwb3J0Q2hhbmdlIiwib25SZXN1bHQiLCJpZCIsImNlbnRlciIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiYmJveEV4Y2VwdGlvbnMiLCJuYW1lIiwid2lkdGgiLCJoZWlnaHQiLCJ0cmFuc2l0aW9uSW50ZXJwb2xhdG9yIiwiRmx5VG9JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJwbGFjZV9uYW1lIiwib25FcnJvciIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm9iamVjdCIsImlzUmVxdWlyZWQiLCJmdW5jIiwic3RyaW5nIiwibnVtYmVyIiwiYm9vbCIsImFycmF5Iiwib25lT2YiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsa0JBQWtCLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEIsYUFBMUIsRUFBeUMsY0FBekMsQ0FBeEI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQkMsTUFBbkIsRUFBMkJDLFFBQTNCLEVBQXFDO0FBQ25DLFNBQU8sSUFBSUMsaUNBQUosQ0FBd0JELFFBQXhCLEVBQWtDRixTQUFsQyxDQUE0Q0MsTUFBNUMsQ0FBUDtBQUNEOztBQUVELFNBQVNHLGNBQVQsR0FBMEI7QUFDeEIsTUFBSUMsY0FBYyxJQUFsQjs7QUFFQSxNQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU9DLFFBQTVDLEVBQXNEO0FBQ3BELFFBQU1DLFFBQVFGLE9BQU9DLFFBQVAsQ0FBZ0JFLE1BQWhCLENBQXVCRCxLQUF2QixDQUE2Qix1QkFBN0IsQ0FBZDtBQUNBSCxrQkFBY0csU0FBU0EsTUFBTSxDQUFOLENBQXZCO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDSCxXQUFELElBQWdCLE9BQU9LLE9BQVAsS0FBbUIsV0FBdkMsRUFBb0Q7QUFDbEQ7QUFDQUwsa0JBQWNBLGVBQWVLLFFBQVFDLEdB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LElBdkJIO0FBd0JqQk4sV0FBU0csb0JBQVVHLElBeEJGO0FBeUJqQnBELFdBQVNpRCxvQkFBVUMsTUF6QkYsQ0F5QlM7QUF6QlQsQztBQXpMZnpFLFEsQ0FxTkdpRixZLEdBQWU7QUFDcEIxQixvQkFBa0IsNEJBQU0sQ0FBRSxDQUROO0FBRXBCOUMsd0JBQXNCbEIsZ0JBRkY7QUFHcEJvQixRQUFNLEVBSGM7QUFJcEJDLGVBQWEsUUFKTztBQUtwQkUsa0JBQWdCLEtBTEk7QUFNcEJJLGFBQVcsQ0FOUztBQU9wQkMsU0FBTyxDQVBhO0FBUXBCTSxZQUFVLFdBUlU7QUFTcEJELFVBQVEsa0JBQU0sQ0FBRSxDQVRJO0FBVXBCMEIsV0FBUyxtQkFBTSxDQUFFLENBVkc7QUFXcEJFLGFBQVcscUJBQU0sQ0FBRSxDQVhDO0FBWXBCQyxhQUFXLHFCQUFNLENBQUUsQ0FaQztBQWFwQkcsWUFBVSxvQkFBTSxDQUFFLENBYkU7QUFjcEJhLFdBQVMsbUJBQU0sQ0FBRTtBQWRHLEM7a0JBa0JUckUsUSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnQG1hcGJveC9tYXBib3gtZ2wtZ2VvY29kZXIvZGlzdC9tYXBib3gtZ2wtZ2VvY29kZXIuY3NzJ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgTWFwYm94R2VvY29kZXIgZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtZ2VvY29kZXInXG5pbXBvcnQgeyBGbHlUb0ludGVycG9sYXRvciB9IGZyb20gJ3JlYWN0LW1hcC1nbCdcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnXG5cbmNvbnN0IFZBTElEX1BPU0lUSU9OUyA9IFsndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCddXG5cbmZ1bmN0aW9uIGZpdEJvdW5kcyhib3VuZHMsIHZpZXdwb3J0KSB7XG4gIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydCkuZml0Qm91bmRzKGJvdW5kcylcbn1cblxuZnVuY3Rpb24gZ2V0QWNjZXNzVG9rZW4oKSB7XG4gIGxldCBhY2Nlc3NUb2tlbiA9IG51bGxcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9hY2Nlc3NfdG9rZW49KFteJi9dKikvKVxuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV1cbiAgfVxuXG4gIGlmICghYWNjZXNzVG9rZW4gJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm90ZTogVGhpcyBkZXBlbmRzIG9uIGJ1bmRsZXIgcGx1Z2lucyAoZS5nLiB3ZWJwYWNrKSBpbm1wb3J0aW5nIGVudmlyb25tZW50IGNvcnJlY3RseVxuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuTWFwYm94QWNjZXNzVG9rZW4gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgcmV0dXJuIGFjY2Vzc1Rva2VuIHx8IG51bGxcbn1cblxuY2xhc3MgR2VvY29kZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBnZW9jb2RlciA9IG51bGxcbiAgY2FjaGVkSW5wdXRWYWx1ZSA9ICcnXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplR2VvY29kZXIoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5yZW1vdmVHZW9jb2RlcigpXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5yZW1vdmVHZW9jb2RlcigpXG4gICAgdGhpcy5pbml0aWFsaXplR2VvY29kZXIoKVxuICB9XG5cbiAgaW5pdGlhbGl6ZUdlb2NvZGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IG1hcGJveE1hcCA9IHRoaXMuZ2V0TWFwYm94TWFwKClcbiAgICBjb25zdCBjb250YWluZXJOb2RlID0gdGhpcy5nZXRDb250YWluZXJOb2RlKClcbiAgICBjb25zdCB7XG4gICAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgIGlucHV0VmFsdWUsXG4gICAgICB6b29tLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBwcm94aW1pdHksXG4gICAgICB0cmFja1Byb3hpbWl0eSxcbiAgICAgIGJib3gsXG4gICAgICB0eXBlcyxcbiAgICAgIGNvdW50cnksXG4gICAgICBtaW5MZW5ndGgsXG4gICAgICBsaW1pdCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlsdGVyLFxuICAgICAgbG9jYWxHZW9jb2RlcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvbkluaXQsXG4gICAgICBwb3NpdGlvblxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICB0aGlzLmdlb2NvZGVyID0gbmV3IE1hcGJveEdlb2NvZGVyKHtcbiAgICAgIGFjY2Vzc1Rva2VuOiBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgIHpvb20sXG4gICAgICBmbHlUbzogZmFsc2UsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHByb3hpbWl0eSxcbiAgICAgIHRyYWNrUHJveGltaXR5LFxuICAgICAgYmJveCxcbiAgICAgIHR5cGVzLFxuICAgICAgY291bnRyeSxcbiAgICAgIG1pbkxlbmd0aCxcbiAgICAgIGxpbWl0LFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBmaWx0ZXIsXG4gICAgICBsb2NhbEdlb2NvZGVyLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pXG4gICAgdGhpcy5zdWJzY3JpYmVFdmVudHMoKVxuXG4gICAgaWYgKGNvbnRhaW5lck5vZGUpIHtcbiAgICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQodGhpcy5nZW9jb2Rlci5vbkFkZChtYXBib3hNYXApKVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXBib3hNYXAuYWRkQ29udHJvbCh0aGlzLmdlb2NvZGVyLCBWQUxJRF9QT1NJVElPTlMuZmluZCgoX3Bvc2l0aW9uKSA9PiBwb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSlcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkSW5wdXRWYWx1ZSA9IGlucHV0VmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLmdlb2NvZGVyLnNldElucHV0KHRoaXMuY2FjaGVkSW5wdXRWYWx1ZSlcbiAgICBvbkluaXQodGhpcy5nZW9jb2RlcilcbiAgfVxuXG4gIGdldE1hcGJveE1hcCA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1hcFJlZiB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIChtYXBSZWYgJiYgbWFwUmVmLmN1cnJlbnQgJiYgbWFwUmVmLmN1cnJlbnQuZ2V0TWFwKCkpIHx8IG51bGxcbiAgfVxuXG4gIGdldENvbnRhaW5lck5vZGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjb250YWluZXJSZWYgfSA9IHRoaXMucHJvcHNcblxuICAgIHJldHVybiAoY29udGFpbmVyUmVmICYmIGNvbnRhaW5lclJlZi5jdXJyZW50KSB8fCBudWxsXG4gIH1cblxuICBzdWJzY3JpYmVFdmVudHMgPSAoKSA9PiB7XG4gICAgdGhpcy5nZW9jb2Rlci5vbignY2xlYXInLCB0aGlzLmhhbmRsZUNsZWFyKVxuICAgIHRoaXMuZ2VvY29kZXIub24oJ2xvYWRpbmcnLCB0aGlzLmhhbmRsZUxvYWRpbmcpXG4gICAgdGhpcy5nZW9jb2Rlci5vbigncmVzdWx0cycsIHRoaXMuaGFuZGxlUmVzdWx0cylcbiAgICB0aGlzLmdlb2NvZGVyLm9uKCdyZXN1bHQnLCB0aGlzLmhhbmRsZVJlc3VsdClcbiAgICB0aGlzLmdlb2NvZGVyLm9uKCdlcnJvcicsIHRoaXMuaGFuZGxlRXJyb3IpXG4gIH1cblxuICB1bnN1YnNjcmliZUV2ZW50cyA9ICgpID0+IHtcbiAgICB0aGlzLmdlb2NvZGVyLm9mZignY2xlYXInLCB0aGlzLmhhbmRsZUNsZWFyKVxuICAgIHRoaXMuZ2VvY29kZXIub2ZmKCdsb2FkaW5nJywgdGhpcy5oYW5kbGVMb2FkaW5nKVxuICAgIHRoaXMuZ2VvY29kZXIub2ZmKCdyZXN1bHRzJywgdGhpcy5oYW5kbGVSZXN1bHRzKVxuICAgIHRoaXMuZ2VvY29kZXIub2ZmKCdyZXN1bHQnLCB0aGlzLmhhbmRsZVJlc3VsdClcbiAgICB0aGlzLmdlb2NvZGVyLm9mZignZXJyb3InLCB0aGlzLmhhbmRsZUVycm9yKVxuICB9XG5cbiAgcmVtb3ZlR2VvY29kZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgbWFwYm94TWFwID0gdGhpcy5nZXRNYXBib3hNYXAoKVxuXG4gICAgdGhpcy51bnN1YnNjcmliZUV2ZW50cygpXG5cbiAgICBpZiAobWFwYm94TWFwICYmIG1hcGJveE1hcC5yZW1vdmVDb250cm9sKSB7XG4gICAgICB0aGlzLmdldE1hcGJveE1hcCgpLnJlbW92ZUNvbnRyb2wodGhpcy5nZW9jb2RlcilcbiAgICB9XG5cbiAgICB0aGlzLmdlb2NvZGVyID0gbnVsbFxuICB9XG5cbiAgaGFuZGxlQ2xlYXIgPSAoKSA9PiB7XG4gICAgdGhpcy5jYWNoZWRJbnB1dFZhbHVlID0gJydcbiAgICB0aGlzLnByb3BzLm9uQ2xlYXIoKVxuICB9XG5cbiAgaGFuZGxlTG9hZGluZyA9IChldmVudCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25Mb2FkaW5nKGV2ZW50KVxuICB9XG5cbiAgaGFuZGxlUmVzdWx0cyA9IChldmVudCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25SZXN1bHRzKGV2ZW50KVxuICB9XG5cbiAgaGFuZGxlUmVzdWx0ID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IGV2ZW50XG4gICAgY29uc3QgeyBtYXBSZWYsIG9uVmlld3BvcnRDaGFuZ2UsIG9uUmVzdWx0IH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBpZCwgYmJveCwgY2VudGVyIH0gPSByZXN1bHRcbiAgICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gPSBjZW50ZXJcbiAgICBjb25zdCBiYm94RXhjZXB0aW9ucyA9IHtcbiAgICAgICdjb3VudHJ5LjMxNDgnOiB7XG4gICAgICAgIG5hbWU6ICdGcmFuY2UnLFxuICAgICAgICBiYm94OiBbWy00LjU5MjM1LCA0MS4zODAwMDddLCBbOS41NjAwMTYsIDUxLjE0ODUwNl1dXG4gICAgICB9LFxuICAgICAgJ2NvdW50cnkuMzE0NSc6IHtcbiAgICAgICAgbmFtZTogJ1VuaXRlZCBTdGF0ZXMnLFxuICAgICAgICBiYm94OiBbWy0xNzEuNzkxMTExLCAxOC45MTYxOV0sIFstNjYuOTY0NjYsIDcxLjM1Nzc2NF1dXG4gICAgICB9LFxuICAgICAgJ2NvdW50cnkuMzMwJzoge1xuICAgICAgICBuYW1lOiAnUnVzc2lhJyxcbiAgICAgICAgYmJveDogW1sxOS42NjA2NCwgNDEuMTUxNDE2XSwgWzE5MC4xMDA0MiwgODEuMjUwNF1dXG4gICAgICB9LFxuICAgICAgJ2NvdW50cnkuMzE3OSc6IHtcbiAgICAgICAgbmFtZTogJ0NhbmFkYScsXG4gICAgICAgIGJib3g6IFtbLTE0MC45OTc3OCwgNDEuNjc1MTA1XSwgWy01Mi42NDgwOTksIDgzLjIzMzI0XV1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBtYXBSZWYuY3VycmVudC5wcm9wcy53aWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IG1hcFJlZi5jdXJyZW50LnByb3BzLmhlaWdodFxuICAgIGxldCB6b29tID0gdGhpcy5nZW9jb2Rlci5vcHRpb25zLnpvb21cblxuICAgIGlmICghYmJveEV4Y2VwdGlvbnNbaWRdICYmIGJib3gpIHtcbiAgICAgIHpvb20gPSBmaXRCb3VuZHMoW1tiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbM11dXSwgeyB3aWR0aCwgaGVpZ2h0IH0pLnpvb21cbiAgICB9IGVsc2UgaWYgKGJib3hFeGNlcHRpb25zW2lkXSkge1xuICAgICAgem9vbSA9IGZpdEJvdW5kcyhiYm94RXhjZXB0aW9uc1tpZF0uYmJveCwgeyB3aWR0aCwgaGVpZ2h0IH0pLnpvb21cbiAgICB9XG5cbiAgICBvblZpZXdwb3J0Q2hhbmdlKHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBGbHlUb0ludGVycG9sYXRvcigpLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAwXG4gICAgfSlcbiAgICBvblJlc3VsdChldmVudClcblxuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnBsYWNlX25hbWUpIHtcbiAgICAgIHRoaXMuY2FjaGVkSW5wdXRWYWx1ZSA9IHJlc3VsdC5wbGFjZV9uYW1lXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXZlbnQpXG4gIH1cblxuICBnZXRHZW9jb2RlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9jb2RlclxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG1hcFJlZjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbnRhaW5lclJlZjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpbnB1dFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJveGltaXR5OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRyYWNrUHJveGltaXR5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBiYm94OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgdHlwZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY291bnRyeTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtaW5MZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbGltaXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbGFuZ3VhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBsb2NhbEdlb2NvZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFZBTElEX1BPU0lUSU9OUyksXG4gICAgb25Jbml0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVzdWx0czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZXN1bHQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QgLy8gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIG9uVmlld3BvcnRDaGFuZ2U6ICgpID0+IHt9LFxuICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBnZXRBY2Nlc3NUb2tlbigpLFxuICAgIHpvb206IDE2LFxuICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoJyxcbiAgICB0cmFja1Byb3hpbWl0eTogZmFsc2UsXG4gICAgbWluTGVuZ3RoOiAyLFxuICAgIGxpbWl0OiA1LFxuICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0JyxcbiAgICBvbkluaXQ6ICgpID0+IHt9LFxuICAgIG9uQ2xlYXI6ICgpID0+IHt9LFxuICAgIG9uTG9hZGluZzogKCkgPT4ge30sXG4gICAgb25SZXN1bHRzOiAoKSA9PiB7fSxcbiAgICBvblJlc3VsdDogKCkgPT4ge30sXG4gICAgb25FcnJvcjogKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlclxuIl19